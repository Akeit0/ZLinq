// <auto-generated />
#pragma warning disable
#nullable enable
using System;
using System.Linq;
using System.Collections.Generic;
#if NET8_0_OR_GREATER
using System.Numerics;
#endif
using ZLinq;
using ZLinq.Linq;

internal static partial class ZLinqDropInExtensions
{
    public static TSource Aggregate<TSource>(this IEnumerable<TSource> source, Func<TSource, TSource, TSource> func) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Aggregate(func);
    public static TAccumulate Aggregate<TSource, TAccumulate>(this IEnumerable<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Aggregate(seed, func);
    public static TResult Aggregate<TSource, TAccumulate, TResult>(this IEnumerable<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func, Func<TAccumulate, TResult> resultSelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Aggregate(seed, func, resultSelector);
    public static ValueEnumerable<AggregateBy<FromEnumerable<TSource>, TSource, TKey, TAccumulate>, KeyValuePair<TKey, TAccumulate>> AggregateBy<TSource, TKey, TAccumulate>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().AggregateBy(keySelector, seed, func);
    public static ValueEnumerable<AggregateBy<FromEnumerable<TSource>, TSource, TKey, TAccumulate>, KeyValuePair<TKey, TAccumulate>> AggregateBy<TSource, TKey, TAccumulate>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func, IEqualityComparer<TKey>? keyComparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().AggregateBy(keySelector, seed, func, keyComparer);
    public static ValueEnumerable<AggregateBy2<FromEnumerable<TSource>, TSource, TKey, TAccumulate>, KeyValuePair<TKey, TAccumulate>> AggregateBy<TSource, TKey, TAccumulate>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, TAccumulate> seedSelector, Func<TAccumulate, TSource, TAccumulate> func) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().AggregateBy(keySelector, seedSelector, func);
    public static ValueEnumerable<AggregateBy2<FromEnumerable<TSource>, TSource, TKey, TAccumulate>, KeyValuePair<TKey, TAccumulate>> AggregateBy<TSource, TKey, TAccumulate>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, TAccumulate> seedSelector, Func<TAccumulate, TSource, TAccumulate> func, IEqualityComparer<TKey>? keyComparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().AggregateBy(keySelector, seedSelector, func, keyComparer);
    public static Boolean All<TSource>(this IEnumerable<TSource> source, Func<TSource, Boolean> predicate) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().All(predicate);
    public static Boolean Any<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Any();
    public static Boolean Any<TSource>(this IEnumerable<TSource> source, Func<TSource, Boolean> predicate) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Any(predicate);
    public static ValueEnumerable<Append<FromEnumerable<TSource>, TSource>, TSource> Append<TSource>(this IEnumerable<TSource> source, TSource element) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Append(element);
    public static Single Average(this IEnumerable<Single> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Average();
    public static Nullable<Single> Average(this IEnumerable<Nullable<Single>> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Average();
    public static Single Average<TSource>(this IEnumerable<TSource> source, Func<TSource, Single> selector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Average(selector);
    public static Nullable<Single> Average<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<Single>> selector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Average(selector);
    public static Decimal Average(this IEnumerable<Decimal> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Average();
    public static Nullable<Decimal> Average(this IEnumerable<Nullable<Decimal>> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Average();
    public static Decimal Average<TSource>(this IEnumerable<TSource> source, Func<TSource, Decimal> selector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Average(selector);
    public static Nullable<Decimal> Average<TSource>(this IEnumerable<TSource> source, Func<TSource, Nullable<Decimal>> selector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Average(selector);
    public static Double Average<TSource>(this IEnumerable<TSource> source)
        where TSource : struct
#if NET8_0_OR_GREATER
        , INumber<TSource>
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Average();
    public static Nullable<Double> Average<TSource>(this IEnumerable<Nullable<TSource>> source)
        where TSource : struct
#if NET8_0_OR_GREATER
        , INumber<TSource>
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Average();
    public static Double Average<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)
        where TResult : struct
#if NET8_0_OR_GREATER
        , INumber<TResult>
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Average(selector);
    public static Nullable<Double> Average<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, Nullable<TResult>> selector)
        where TResult : struct
#if NET8_0_OR_GREATER
        , INumber<TResult>
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Average(selector);
    public static ValueEnumerable<Chunk<FromEnumerable<TSource>, TSource>, TSource[]> Chunk<TSource>(this IEnumerable<TSource> source, Int32 size) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Chunk(size);
    public static ValueEnumerable<Concat<FromEnumerable<TSource>, TEnumerator2, TSource>, TSource> Concat<TEnumerator2, TSource>(this IEnumerable<TSource> source, ValueEnumerable<TEnumerator2, TSource> second)
        where TEnumerator2 : struct, IValueEnumerator<TSource>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Concat(second);
    public static ValueEnumerable<Concat<FromEnumerable<TSource>, FromEnumerable<TSource>, TSource>, TSource> Concat<TSource>(this IEnumerable<TSource> source, IEnumerable<TSource> second) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Concat(second);
    public static Boolean Contains<TSource>(this IEnumerable<TSource> source, TSource value) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Contains(value);
    public static Boolean Contains<TSource>(this IEnumerable<TSource> source, TSource value, IEqualityComparer<TSource>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Contains(value, comparer);
    public static Int32 CopyTo<TSource>(this IEnumerable<TSource> source, Span<TSource> destination) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().CopyTo(destination);
    public static void CopyTo<TSource>(this IEnumerable<TSource> source, List<TSource> list) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().CopyTo(list);
    public static Int32 Count<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Count();
    public static Int32 Count<TSource>(this IEnumerable<TSource> source, Func<TSource, Boolean> predicate) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Count(predicate);
    public static ValueEnumerable<CountBy<FromEnumerable<TSource>, TSource, TKey>, KeyValuePair<TKey, Int32>> CountBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().CountBy(keySelector);
    public static ValueEnumerable<CountBy<FromEnumerable<TSource>, TSource, TKey>, KeyValuePair<TKey, Int32>> CountBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey>? keyComparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().CountBy(keySelector, keyComparer);
    public static ValueEnumerable<DefaultIfEmpty<FromEnumerable<TSource>, TSource>, TSource> DefaultIfEmpty<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().DefaultIfEmpty();
    public static ValueEnumerable<DefaultIfEmpty<FromEnumerable<TSource>, TSource>, TSource> DefaultIfEmpty<TSource>(this IEnumerable<TSource> source, TSource defaultValue) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().DefaultIfEmpty(defaultValue);
    public static ValueEnumerable<Distinct<FromEnumerable<TSource>, TSource>, TSource> Distinct<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Distinct();
    public static ValueEnumerable<Distinct<FromEnumerable<TSource>, TSource>, TSource> Distinct<TSource>(this IEnumerable<TSource> source, IEqualityComparer<TSource>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Distinct(comparer);
    public static ValueEnumerable<DistinctBy<FromEnumerable<TSource>, TSource, TKey>, TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().DistinctBy(keySelector);
    public static ValueEnumerable<DistinctBy<FromEnumerable<TSource>, TSource, TKey>, TSource> DistinctBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().DistinctBy(keySelector, comparer);
    public static TSource ElementAt<TSource>(this IEnumerable<TSource> source, Int32 index) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ElementAt(index);
    public static TSource ElementAt<TSource>(this IEnumerable<TSource> source, Index index) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ElementAt(index);
    public static TSource? ElementAtOrDefault<TSource>(this IEnumerable<TSource> source, Int32 index) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ElementAtOrDefault(index);
    public static TSource? ElementAtOrDefault<TSource>(this IEnumerable<TSource> source, Index index) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ElementAtOrDefault(index);
    public static ValueEnumerable<Except<FromEnumerable<TSource>, TEnumerator2, TSource>, TSource> Except<TEnumerator2, TSource>(this IEnumerable<TSource> source, ValueEnumerable<TEnumerator2, TSource> second)
        where TEnumerator2 : struct, IValueEnumerator<TSource>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Except(second);
    public static ValueEnumerable<Except<FromEnumerable<TSource>, TEnumerator2, TSource>, TSource> Except<TEnumerator2, TSource>(this IEnumerable<TSource> source, ValueEnumerable<TEnumerator2, TSource> second, IEqualityComparer<TSource>? comparer)
        where TEnumerator2 : struct, IValueEnumerator<TSource>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Except(second, comparer);
    public static ValueEnumerable<Except<FromEnumerable<TSource>, FromEnumerable<TSource>, TSource>, TSource> Except<TSource>(this IEnumerable<TSource> source, IEnumerable<TSource> second) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Except(second);
    public static ValueEnumerable<Except<FromEnumerable<TSource>, FromEnumerable<TSource>, TSource>, TSource> Except<TSource>(this IEnumerable<TSource> source, IEnumerable<TSource> second, IEqualityComparer<TSource>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Except(second, comparer);
    public static ValueEnumerable<ExceptBy<FromEnumerable<TSource>, TEnumerator2, TSource, TKey>, TSource> ExceptBy<TEnumerator2, TSource, TKey>(this IEnumerable<TSource> source, ValueEnumerable<TEnumerator2, TKey> second, Func<TSource, TKey> keySelector)
        where TEnumerator2 : struct, IValueEnumerator<TKey>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ExceptBy(second, keySelector);
    public static ValueEnumerable<ExceptBy<FromEnumerable<TSource>, TEnumerator2, TSource, TKey>, TSource> ExceptBy<TEnumerator2, TSource, TKey>(this IEnumerable<TSource> source, ValueEnumerable<TEnumerator2, TKey> second, Func<TSource, TKey> keySelector, IEqualityComparer<TKey>? comparer)
        where TEnumerator2 : struct, IValueEnumerator<TKey>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ExceptBy(second, keySelector, comparer);
    public static ValueEnumerable<ExceptBy<FromEnumerable<TSource>, FromEnumerable<TKey>, TSource, TKey>, TSource> ExceptBy<TSource, TKey>(this IEnumerable<TSource> source, IEnumerable<TKey> second, Func<TSource, TKey> keySelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ExceptBy(second, keySelector);
    public static ValueEnumerable<ExceptBy<FromEnumerable<TSource>, FromEnumerable<TKey>, TSource, TKey>, TSource> ExceptBy<TSource, TKey>(this IEnumerable<TSource> source, IEnumerable<TKey> second, Func<TSource, TKey> keySelector, IEqualityComparer<TKey>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ExceptBy(second, keySelector, comparer);
    public static TSource First<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().First();
    public static TSource First<TSource>(this IEnumerable<TSource> source, Func<TSource, Boolean> predicate) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().First(predicate);
    public static TSource? FirstOrDefault<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().FirstOrDefault();
    public static TSource FirstOrDefault<TSource>(this IEnumerable<TSource> source, TSource defaultValue) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().FirstOrDefault(defaultValue);
    public static TSource? FirstOrDefault<TSource>(this IEnumerable<TSource> source, Func<TSource, Boolean> predicate) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().FirstOrDefault(predicate);
    public static TSource FirstOrDefault<TSource>(this IEnumerable<TSource> source, Func<TSource, Boolean> predicate, TSource defaultValue) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().FirstOrDefault(predicate, defaultValue);
    public static ValueEnumerable<GroupBy<FromEnumerable<TSource>, TSource, TKey>, IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().GroupBy(keySelector);
    public static ValueEnumerable<GroupBy<FromEnumerable<TSource>, TSource, TKey>, IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().GroupBy(keySelector, comparer);
    public static ValueEnumerable<GroupBy2<FromEnumerable<TSource>, TSource, TKey, TElement>, IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().GroupBy(keySelector, elementSelector);
    public static ValueEnumerable<GroupBy2<FromEnumerable<TSource>, TSource, TKey, TElement>, IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().GroupBy(keySelector, elementSelector, comparer);
    public static ValueEnumerable<GroupBy3<FromEnumerable<TSource>, TSource, TKey, TResult>, TResult> GroupBy<TSource, TKey, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().GroupBy(keySelector, resultSelector);
    public static ValueEnumerable<GroupBy3<FromEnumerable<TSource>, TSource, TKey, TResult>, TResult> GroupBy<TSource, TKey, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector, IEqualityComparer<TKey>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().GroupBy(keySelector, resultSelector, comparer);
    public static ValueEnumerable<GroupBy4<FromEnumerable<TSource>, TSource, TKey, TElement, TResult>, TResult> GroupBy<TSource, TKey, TElement, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().GroupBy(keySelector, elementSelector, resultSelector);
    public static ValueEnumerable<GroupBy4<FromEnumerable<TSource>, TSource, TKey, TElement, TResult>, TResult> GroupBy<TSource, TKey, TElement, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, IEqualityComparer<TKey>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().GroupBy(keySelector, elementSelector, resultSelector, comparer);
    public static ValueEnumerable<GroupJoin<FromEnumerable<TOuter>, TEnumerator2, TOuter, TInner, TKey, TResult>, TResult> GroupJoin<TEnumerator2, TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> source, ValueEnumerable<TEnumerator2, TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector)
        where TEnumerator2 : struct, IValueEnumerator<TInner>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().GroupJoin(inner, outerKeySelector, innerKeySelector, resultSelector);
    public static ValueEnumerable<GroupJoin<FromEnumerable<TOuter>, TEnumerator2, TOuter, TInner, TKey, TResult>, TResult> GroupJoin<TEnumerator2, TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> source, ValueEnumerable<TEnumerator2, TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey>? comparer)
        where TEnumerator2 : struct, IValueEnumerator<TInner>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().GroupJoin(inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
    public static ValueEnumerable<GroupJoin<FromEnumerable<TOuter>, FromEnumerable<TInner>, TOuter, TInner, TKey, TResult>, TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> source, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().GroupJoin(inner, outerKeySelector, innerKeySelector, resultSelector);
    public static ValueEnumerable<GroupJoin<FromEnumerable<TOuter>, FromEnumerable<TInner>, TOuter, TInner, TKey, TResult>, TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> source, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().GroupJoin(inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
    public static ValueEnumerable<Index<FromEnumerable<TSource>, TSource>, (int Index, TSource Item)> Index<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Index();
    public static ValueEnumerable<Intersect<FromEnumerable<TSource>, TEnumerator2, TSource>, TSource> Intersect<TEnumerator2, TSource>(this IEnumerable<TSource> source, ValueEnumerable<TEnumerator2, TSource> second)
        where TEnumerator2 : struct, IValueEnumerator<TSource>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Intersect(second);
    public static ValueEnumerable<Intersect<FromEnumerable<TSource>, TEnumerator2, TSource>, TSource> Intersect<TEnumerator2, TSource>(this IEnumerable<TSource> source, ValueEnumerable<TEnumerator2, TSource> second, IEqualityComparer<TSource>? comparer)
        where TEnumerator2 : struct, IValueEnumerator<TSource>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Intersect(second, comparer);
    public static ValueEnumerable<Intersect<FromEnumerable<TSource>, FromEnumerable<TSource>, TSource>, TSource> Intersect<TSource>(this IEnumerable<TSource> source, IEnumerable<TSource> second) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Intersect(second);
    public static ValueEnumerable<Intersect<FromEnumerable<TSource>, FromEnumerable<TSource>, TSource>, TSource> Intersect<TSource>(this IEnumerable<TSource> source, IEnumerable<TSource> second, IEqualityComparer<TSource>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Intersect(second, comparer);
    public static ValueEnumerable<IntersectBy<FromEnumerable<TSource>, TEnumerator2, TSource, TKey>, TSource> IntersectBy<TEnumerator2, TSource, TKey>(this IEnumerable<TSource> source, ValueEnumerable<TEnumerator2, TKey> second, Func<TSource, TKey> keySelector)
        where TEnumerator2 : struct, IValueEnumerator<TKey>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().IntersectBy(second, keySelector);
    public static ValueEnumerable<IntersectBy<FromEnumerable<TSource>, TEnumerator2, TSource, TKey>, TSource> IntersectBy<TEnumerator2, TSource, TKey>(this IEnumerable<TSource> source, ValueEnumerable<TEnumerator2, TKey> second, Func<TSource, TKey> keySelector, IEqualityComparer<TKey>? comparer)
        where TEnumerator2 : struct, IValueEnumerator<TKey>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().IntersectBy(second, keySelector, comparer);
    public static ValueEnumerable<IntersectBy<FromEnumerable<TSource>, FromEnumerable<TKey>, TSource, TKey>, TSource> IntersectBy<TSource, TKey>(this IEnumerable<TSource> source, IEnumerable<TKey> second, Func<TSource, TKey> keySelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().IntersectBy(second, keySelector);
    public static ValueEnumerable<IntersectBy<FromEnumerable<TSource>, FromEnumerable<TKey>, TSource, TKey>, TSource> IntersectBy<TSource, TKey>(this IEnumerable<TSource> source, IEnumerable<TKey> second, Func<TSource, TKey> keySelector, IEqualityComparer<TKey>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().IntersectBy(second, keySelector, comparer);
    public static ValueEnumerable<Join<FromEnumerable<TOuter>, TEnumerator2, TOuter, TInner, TKey, TResult>, TResult> Join<TEnumerator2, TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> source, ValueEnumerable<TEnumerator2, TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector)
        where TEnumerator2 : struct, IValueEnumerator<TInner>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Join(inner, outerKeySelector, innerKeySelector, resultSelector);
    public static ValueEnumerable<Join<FromEnumerable<TOuter>, TEnumerator2, TOuter, TInner, TKey, TResult>, TResult> Join<TEnumerator2, TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> source, ValueEnumerable<TEnumerator2, TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey>? comparer)
        where TEnumerator2 : struct, IValueEnumerator<TInner>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Join(inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
    public static ValueEnumerable<Join<FromEnumerable<TOuter>, FromEnumerable<TInner>, TOuter, TInner, TKey, TResult>, TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> source, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Join(inner, outerKeySelector, innerKeySelector, resultSelector);
    public static ValueEnumerable<Join<FromEnumerable<TOuter>, FromEnumerable<TInner>, TOuter, TInner, TKey, TResult>, TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> source, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Join(inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
    public static String JoinToString<TSource>(this IEnumerable<TSource> source, String separator) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().JoinToString(separator);
    public static String JoinToString<TSource>(this IEnumerable<TSource> source, Char separator) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().JoinToString(separator);
    public static String JoinToString<TSource>(this IEnumerable<TSource> source, ReadOnlySpan<Char> separator) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().JoinToString(separator);
    public static TSource Last<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Last();
    public static TSource Last<TSource>(this IEnumerable<TSource> source, Func<TSource, Boolean> predicate) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Last(predicate);
    public static TSource? LastOrDefault<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().LastOrDefault();
    public static TSource LastOrDefault<TSource>(this IEnumerable<TSource> source, TSource defaultValue) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().LastOrDefault(defaultValue);
    public static TSource? LastOrDefault<TSource>(this IEnumerable<TSource> source, Func<TSource, Boolean> predicate) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().LastOrDefault(predicate);
    public static TSource LastOrDefault<TSource>(this IEnumerable<TSource> source, Func<TSource, Boolean> predicate, TSource defaultValue) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().LastOrDefault(predicate, defaultValue);
    public static ValueEnumerable<LeftJoin<FromEnumerable<TOuter>, TEnumerator2, TOuter, TInner, TKey, TResult>, TResult> LeftJoin<TEnumerator2, TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> source, ValueEnumerable<TEnumerator2, TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner?, TResult> resultSelector)
        where TEnumerator2 : struct, IValueEnumerator<TInner>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().LeftJoin(inner, outerKeySelector, innerKeySelector, resultSelector);
    public static ValueEnumerable<LeftJoin<FromEnumerable<TOuter>, TEnumerator2, TOuter, TInner, TKey, TResult>, TResult> LeftJoin<TEnumerator2, TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> source, ValueEnumerable<TEnumerator2, TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner?, TResult> resultSelector, IEqualityComparer<TKey>? comparer)
        where TEnumerator2 : struct, IValueEnumerator<TInner>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().LeftJoin(inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
    public static ValueEnumerable<LeftJoin<FromEnumerable<TOuter>, FromEnumerable<TInner>, TOuter, TInner, TKey, TResult>, TResult> LeftJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> source, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner?, TResult> resultSelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().LeftJoin(inner, outerKeySelector, innerKeySelector, resultSelector);
    public static ValueEnumerable<LeftJoin<FromEnumerable<TOuter>, FromEnumerable<TInner>, TOuter, TInner, TKey, TResult>, TResult> LeftJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> source, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner?, TResult> resultSelector, IEqualityComparer<TKey>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().LeftJoin(inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
    public static Int64 LongCount<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().LongCount();
    public static Int64 LongCount<TSource>(this IEnumerable<TSource> source, Func<TSource, Boolean> predicate) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().LongCount(predicate);
    public static TResult? Max<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Max(selector);
    public static TSource? Max<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Max();
    public static TSource? Max<TSource>(this IEnumerable<TSource> source, IComparer<TSource>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Max(comparer);
    public static TSource? MaxBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().MaxBy(keySelector);
    public static TSource? MaxBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().MaxBy(keySelector, comparer);
    public static TResult? Min<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Min(selector);
    public static TSource? Min<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Min();
    public static TSource? Min<TSource>(this IEnumerable<TSource> source, IComparer<TSource>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Min(comparer);
    public static TSource? MinBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().MinBy(keySelector);
    public static TSource? MinBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().MinBy(keySelector, comparer);
    public static ValueEnumerable<OrderBy<FromEnumerable<TSource>, TSource, TSource>, TSource> Order<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Order();
    public static ValueEnumerable<OrderBy<FromEnumerable<TSource>, TSource, TSource>, TSource> Order<TSource>(this IEnumerable<TSource> source, IComparer<TSource>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Order(comparer);
    public static ValueEnumerable<OrderBy<FromEnumerable<TSource>, TSource, TSource>, TSource> OrderDescending<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().OrderDescending();
    public static ValueEnumerable<OrderBy<FromEnumerable<TSource>, TSource, TSource>, TSource> OrderDescending<TSource>(this IEnumerable<TSource> source, IComparer<TSource>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().OrderDescending(comparer);
    public static ValueEnumerable<OrderBy<FromEnumerable<TSource>, TSource, TKey>, TSource> OrderBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().OrderBy(keySelector);
    public static ValueEnumerable<OrderBy<FromEnumerable<TSource>, TSource, TKey>, TSource> OrderBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().OrderBy(keySelector, comparer);
    public static ValueEnumerable<OrderBy<FromEnumerable<TSource>, TSource, TKey>, TSource> OrderByDescending<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().OrderByDescending(keySelector);
    public static ValueEnumerable<OrderBy<FromEnumerable<TSource>, TSource, TKey>, TSource> OrderByDescending<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().OrderByDescending(keySelector, comparer);
    public static ValueEnumerable<Prepend<FromEnumerable<TSource>, TSource>, TSource> Prepend<TSource>(this IEnumerable<TSource> source, TSource element) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Prepend(element);
    public static ValueEnumerable<Reverse<FromEnumerable<TSource>, TSource>, TSource> Reverse<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Reverse();
    public static ValueEnumerable<RightJoin<FromEnumerable<TOuter>, TEnumerator2, TOuter, TInner, TKey, TResult>, TResult> RightJoin<TEnumerator2, TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> source, ValueEnumerable<TEnumerator2, TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter?, TInner, TResult> resultSelector)
        where TEnumerator2 : struct, IValueEnumerator<TInner>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().RightJoin(inner, outerKeySelector, innerKeySelector, resultSelector);
    public static ValueEnumerable<RightJoin<FromEnumerable<TOuter>, TEnumerator2, TOuter, TInner, TKey, TResult>, TResult> RightJoin<TEnumerator2, TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> source, ValueEnumerable<TEnumerator2, TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter?, TInner, TResult> resultSelector, IEqualityComparer<TKey>? comparer)
        where TEnumerator2 : struct, IValueEnumerator<TInner>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().RightJoin(inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
    public static ValueEnumerable<RightJoin<FromEnumerable<TOuter>, FromEnumerable<TInner>, TOuter, TInner, TKey, TResult>, TResult> RightJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> source, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter?, TInner, TResult> resultSelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().RightJoin(inner, outerKeySelector, innerKeySelector, resultSelector);
    public static ValueEnumerable<RightJoin<FromEnumerable<TOuter>, FromEnumerable<TInner>, TOuter, TInner, TKey, TResult>, TResult> RightJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> source, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter?, TInner, TResult> resultSelector, IEqualityComparer<TKey>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().RightJoin(inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
    public static ValueEnumerable<Select<FromEnumerable<TSource>, TSource, TResult>, TResult> Select<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Select(selector);
    public static ValueEnumerable<Select2<FromEnumerable<TSource>, TSource, TResult>, TResult> Select<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, Int32, TResult> selector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Select(selector);
    public static ValueEnumerable<SelectMany<FromEnumerable<TSource>, TEnumerator2, TSource, TResult>, TResult> SelectMany<TEnumerator2, TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, ValueEnumerable<TEnumerator2, TResult>> selector)
        where TEnumerator2 : struct, IValueEnumerator<TResult>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SelectMany(selector);
    public static ValueEnumerable<SelectMany2<FromEnumerable<TSource>, TEnumerator2, TSource, TResult>, TResult> SelectMany<TEnumerator2, TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, Int32, ValueEnumerable<TEnumerator2, TResult>> selector)
        where TEnumerator2 : struct, IValueEnumerator<TResult>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SelectMany(selector);
    public static ValueEnumerable<SelectMany3<FromEnumerable<TSource>, TEnumerator2, TSource, TCollection, TResult>, TResult> SelectMany<TEnumerator2, TSource, TCollection, TResult>(this IEnumerable<TSource> source, Func<TSource, ValueEnumerable<TEnumerator2, TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector)
        where TEnumerator2 : struct, IValueEnumerator<TCollection>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SelectMany(collectionSelector, resultSelector);
    public static ValueEnumerable<SelectMany4<FromEnumerable<TSource>, TEnumerator2, TSource, TCollection, TResult>, TResult> SelectMany<TEnumerator2, TSource, TCollection, TResult>(this IEnumerable<TSource> source, Func<TSource, Int32, ValueEnumerable<TEnumerator2, TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector)
        where TEnumerator2 : struct, IValueEnumerator<TCollection>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SelectMany(collectionSelector, resultSelector);
    public static ValueEnumerable<SelectMany<FromEnumerable<TSource>, TSource, TResult>, TResult> SelectMany<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, IEnumerable<TResult>> selector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SelectMany(selector);
    public static ValueEnumerable<SelectMany2<FromEnumerable<TSource>, TSource, TResult>, TResult> SelectMany<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, Int32, IEnumerable<TResult>> selector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SelectMany(selector);
    public static ValueEnumerable<SelectMany3<FromEnumerable<TSource>, TSource, TCollection, TResult>, TResult> SelectMany<TSource, TCollection, TResult>(this IEnumerable<TSource> source, Func<TSource, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SelectMany(collectionSelector, resultSelector);
    public static ValueEnumerable<SelectMany4<FromEnumerable<TSource>, TSource, TCollection, TResult>, TResult> SelectMany<TSource, TCollection, TResult>(this IEnumerable<TSource> source, Func<TSource, Int32, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SelectMany(collectionSelector, resultSelector);
    public static Boolean SequenceEqual<TSource>(this IEnumerable<TSource> source, IEnumerable<TSource> second) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SequenceEqual(second);
    public static Boolean SequenceEqual<TSource>(this IEnumerable<TSource> source, IEnumerable<TSource> second, IEqualityComparer<TSource>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SequenceEqual(second, comparer);
    public static Boolean SequenceEqual<TEnumerator2, TSource>(this IEnumerable<TSource> source, ValueEnumerable<TEnumerator2, TSource> second)
        where TEnumerator2 : struct, IValueEnumerator<TSource>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SequenceEqual(second);
    public static Boolean SequenceEqual<TEnumerator2, TSource>(this IEnumerable<TSource> source, ValueEnumerable<TEnumerator2, TSource> second, IEqualityComparer<TSource>? comparer)
        where TEnumerator2 : struct, IValueEnumerator<TSource>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SequenceEqual(second, comparer);
    public static ValueEnumerable<Shuffle<FromEnumerable<TSource>, TSource>, TSource> Shuffle<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Shuffle();
    public static TSource Single<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Single();
    public static TSource Single<TSource>(this IEnumerable<TSource> source, Func<TSource, Boolean> predicate) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Single(predicate);
    public static TSource? SingleOrDefault<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SingleOrDefault();
    public static TSource SingleOrDefault<TSource>(this IEnumerable<TSource> source, TSource defaultValue) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SingleOrDefault(defaultValue);
    public static TSource? SingleOrDefault<TSource>(this IEnumerable<TSource> source, Func<TSource, Boolean> predicate) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SingleOrDefault(predicate);
    public static TSource SingleOrDefault<TSource>(this IEnumerable<TSource> source, Func<TSource, Boolean> predicate, TSource defaultValue) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SingleOrDefault(predicate, defaultValue);
    public static ValueEnumerable<Skip<FromEnumerable<TSource>, TSource>, TSource> Skip<TSource>(this IEnumerable<TSource> source, Int32 count) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Skip(count);
    public static ValueEnumerable<SkipLast<FromEnumerable<TSource>, TSource>, TSource> SkipLast<TSource>(this IEnumerable<TSource> source, Int32 count) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SkipLast(count);
    public static ValueEnumerable<SkipWhile<FromEnumerable<TSource>, TSource>, TSource> SkipWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, Boolean> predicate) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SkipWhile(predicate);
    public static ValueEnumerable<SkipWhile2<FromEnumerable<TSource>, TSource>, TSource> SkipWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, Int32, Boolean> predicate) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SkipWhile(predicate);
    public static TResult Sum<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)
        where TResult : struct
#if NET8_0_OR_GREATER
        , INumber<TResult>
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Sum(selector);
    public static Nullable<TResult> Sum<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, Nullable<TResult>> selector)
        where TResult : struct
#if NET8_0_OR_GREATER
        , INumber<TResult>
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Sum(selector);
    public static Nullable<TSource> Sum<TSource>(this IEnumerable<Nullable<TSource>> source)
        where TSource : struct
#if NET8_0_OR_GREATER
        , INumber<TSource>
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Sum();
    public static TSource Sum<TSource>(this IEnumerable<TSource> source)
        where TSource : struct
#if NET8_0_OR_GREATER
        , INumber<TSource>
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Sum();
#if NET8_0_OR_GREATER
    public static TSource SumUnchecked<TSource>(this IEnumerable<TSource> source)
        where TSource : struct
#if NET8_0_OR_GREATER
        , INumber<TSource>
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().SumUnchecked();
#endif
    public static ValueEnumerable<Take<FromEnumerable<TSource>, TSource>, TSource> Take<TSource>(this IEnumerable<TSource> source, Int32 count) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Take(count);
    public static ValueEnumerable<TakeRange<FromEnumerable<TSource>, TSource>, TSource> Take<TSource>(this IEnumerable<TSource> source, Range range) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Take(range);
    public static ValueEnumerable<TakeLast<FromEnumerable<TSource>, TSource>, TSource> TakeLast<TSource>(this IEnumerable<TSource> source, Int32 count) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().TakeLast(count);
    public static ValueEnumerable<TakeWhile<FromEnumerable<TSource>, TSource>, TSource> TakeWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, Boolean> predicate) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().TakeWhile(predicate);
    public static ValueEnumerable<TakeWhile2<FromEnumerable<TSource>, TSource>, TSource> TakeWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, Int32, Boolean> predicate) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().TakeWhile(predicate);
    public static TSource[] ToArray<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ToArray();
    public static PooledArray<TSource> ToArrayPool<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ToArrayPool();
    public static Dictionary<TKey, TValue> ToDictionary<TKey, TValue>(this IEnumerable<KeyValuePair<TKey, TValue>> source) where TKey : notnull => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ToDictionary();
    public static Dictionary<TKey, TValue> ToDictionary<TKey, TValue>(this IEnumerable<KeyValuePair<TKey, TValue>> source, IEqualityComparer<TKey>? comparer) where TKey : notnull => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ToDictionary(comparer);
    public static Dictionary<TKey, TValue> ToDictionary<TKey, TValue>(this IEnumerable<(TKey Key, TValue Value)> source) where TKey : notnull => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ToDictionary();
    public static Dictionary<TKey, TValue> ToDictionary<TKey, TValue>(this IEnumerable<(TKey Key, TValue Value)> source, IEqualityComparer<TKey>? comparer) where TKey : notnull => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ToDictionary(comparer);
    public static Dictionary<TKey, TSource> ToDictionary<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector) where TKey : notnull => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ToDictionary(keySelector);
    public static Dictionary<TKey, TSource> ToDictionary<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey>? comparer) where TKey : notnull => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ToDictionary(keySelector, comparer);
    public static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector) where TKey : notnull => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ToDictionary(keySelector, elementSelector);
    public static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey>? comparer) where TKey : notnull => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ToDictionary(keySelector, elementSelector, comparer);
    public static HashSet<TSource> ToHashSet<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ToHashSet();
    public static HashSet<TSource> ToHashSet<TSource>(this IEnumerable<TSource> source, IEqualityComparer<TSource>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ToHashSet(comparer);
    public static List<TSource> ToList<TSource>(this IEnumerable<TSource> source) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ToList();
    public static ILookup<TKey, TSource> ToLookup<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ToLookup(keySelector);
    public static ILookup<TKey, TSource> ToLookup<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ToLookup(keySelector, comparer);
    public static ILookup<TKey, TElement> ToLookup<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ToLookup(keySelector, elementSelector);
    public static ILookup<TKey, TElement> ToLookup<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().ToLookup(keySelector, elementSelector, comparer);
    public static Boolean TryGetNonEnumeratedCount<TSource>(this IEnumerable<TSource> source, out Int32 count) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().TryGetNonEnumeratedCount(out count);
    public static ValueEnumerable<Union<FromEnumerable<TSource>, TEnumerator2, TSource>, TSource> Union<TEnumerator2, TSource>(this IEnumerable<TSource> source, ValueEnumerable<TEnumerator2, TSource> second)
        where TEnumerator2 : struct, IValueEnumerator<TSource>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Union(second);
    public static ValueEnumerable<Union<FromEnumerable<TSource>, TEnumerator2, TSource>, TSource> Union<TEnumerator2, TSource>(this IEnumerable<TSource> source, ValueEnumerable<TEnumerator2, TSource> second, IEqualityComparer<TSource>? comparer)
        where TEnumerator2 : struct, IValueEnumerator<TSource>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Union(second, comparer);
    public static ValueEnumerable<Union<FromEnumerable<TSource>, FromEnumerable<TSource>, TSource>, TSource> Union<TSource>(this IEnumerable<TSource> source, IEnumerable<TSource> second) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Union(second);
    public static ValueEnumerable<Union<FromEnumerable<TSource>, FromEnumerable<TSource>, TSource>, TSource> Union<TSource>(this IEnumerable<TSource> source, IEnumerable<TSource> second, IEqualityComparer<TSource>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Union(second, comparer);
    public static ValueEnumerable<UnionBy<FromEnumerable<TSource>, TEnumerator2, TSource, TKey>, TSource> UnionBy<TEnumerator2, TSource, TKey>(this IEnumerable<TSource> source, ValueEnumerable<TEnumerator2, TSource> second, Func<TSource, TKey> keySelector)
        where TEnumerator2 : struct, IValueEnumerator<TSource>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().UnionBy(second, keySelector);
    public static ValueEnumerable<UnionBy<FromEnumerable<TSource>, TEnumerator2, TSource, TKey>, TSource> UnionBy<TEnumerator2, TSource, TKey>(this IEnumerable<TSource> source, ValueEnumerable<TEnumerator2, TSource> second, Func<TSource, TKey> keySelector, IEqualityComparer<TKey>? comparer)
        where TEnumerator2 : struct, IValueEnumerator<TSource>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().UnionBy(second, keySelector, comparer);
    public static ValueEnumerable<UnionBy<FromEnumerable<TSource>, FromEnumerable<TSource>, TSource, TKey>, TSource> UnionBy<TSource, TKey>(this IEnumerable<TSource> source, IEnumerable<TSource> second, Func<TSource, TKey> keySelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().UnionBy(second, keySelector);
    public static ValueEnumerable<UnionBy<FromEnumerable<TSource>, FromEnumerable<TSource>, TSource, TKey>, TSource> UnionBy<TSource, TKey>(this IEnumerable<TSource> source, IEnumerable<TSource> second, Func<TSource, TKey> keySelector, IEqualityComparer<TKey>? comparer) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().UnionBy(second, keySelector, comparer);
    public static ValueEnumerable<Where<FromEnumerable<TSource>, TSource>, TSource> Where<TSource>(this IEnumerable<TSource> source, Func<TSource, Boolean> predicate) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Where(predicate);
    public static ValueEnumerable<Where2<FromEnumerable<TSource>, TSource>, TSource> Where<TSource>(this IEnumerable<TSource> source, Func<TSource, Int32, Boolean> predicate) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Where(predicate);
    public static ValueEnumerable<Zip<FromEnumerable<TFirst>, TEnumerator2, TFirst, TSecond>, (TFirst First, TSecond Second)> Zip<TEnumerator2, TFirst, TSecond>(this IEnumerable<TFirst> source, ValueEnumerable<TEnumerator2, TSecond> second)
        where TEnumerator2 : struct, IValueEnumerator<TSecond>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Zip(second);
    public static ValueEnumerable<Zip<FromEnumerable<TFirst>, TEnumerator2, TEnumerator3, TFirst, TSecond, TThird>, (TFirst First, TSecond Second, TThird Third)> Zip<TEnumerator2, TEnumerator3, TFirst, TSecond, TThird>(this IEnumerable<TFirst> source, ValueEnumerable<TEnumerator2, TSecond> second, ValueEnumerable<TEnumerator3, TThird> third)
        where TEnumerator2 : struct, IValueEnumerator<TSecond>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
        where TEnumerator3 : struct, IValueEnumerator<TThird>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Zip(second, third);
    public static ValueEnumerable<Zip<FromEnumerable<TFirst>, TEnumerator2, TFirst, TSecond, TResult>, TResult> Zip<TEnumerator2, TFirst, TSecond, TResult>(this IEnumerable<TFirst> source, ValueEnumerable<TEnumerator2, TSecond> second, Func<TFirst, TSecond, TResult> resultSelector)
        where TEnumerator2 : struct, IValueEnumerator<TSecond>
#if NET9_0_OR_GREATER
        , allows ref struct
#endif
 => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Zip(second, resultSelector);
    public static ValueEnumerable<Zip<FromEnumerable<TFirst>, FromEnumerable<TSecond>, TFirst, TSecond>, (TFirst First, TSecond Second)> Zip<TFirst, TSecond>(this IEnumerable<TFirst> source, IEnumerable<TSecond> second) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Zip(second);
    public static ValueEnumerable<Zip<FromEnumerable<TFirst>, FromEnumerable<TSecond>, FromEnumerable<TThird>, TFirst, TSecond, TThird>, (TFirst First, TSecond Second, TThird Third)> Zip<TFirst, TSecond, TThird>(this IEnumerable<TFirst> source, IEnumerable<TSecond> second, IEnumerable<TThird> third) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Zip(second, third);
    public static ValueEnumerable<Zip<FromEnumerable<TFirst>, FromEnumerable<TSecond>, TFirst, TSecond, TResult>, TResult> Zip<TFirst, TSecond, TResult>(this IEnumerable<TFirst> source, IEnumerable<TSecond> second, Func<TFirst, TSecond, TResult> resultSelector) => (source ?? throw new ArgumentNullException("source")).AsValueEnumerable().Zip(second, resultSelector);
    public static ValueEnumerable<Cast<FromEnumerable<object>, object, TResult>, TResult> Cast<TResult>(this System.Collections.IEnumerable source) => System.Linq.Enumerable.Cast<object>(source).AsValueEnumerable().Cast<TResult>();
    public static ValueEnumerable<OfType<FromEnumerable<object>, object, TResult>, TResult> OfType<TResult>(this System.Collections.IEnumerable source) => System.Linq.Enumerable.Cast<object>(source).AsValueEnumerable().OfType<TResult>();
}
